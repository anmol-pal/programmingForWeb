// Immutable API
export class Err {
    message;
    options;
    constructor(message, options) {
        this.message = message;
        this.options = options;
    }
}
;
/** factory function to build an Err from different types of args */
export function error(e, options) {
    const opts = (typeof options === 'string') ? { code: options } : options;
    return (typeof e === 'string')
        ? new Err(e, opts)
        : (e instanceof Err)
            ? e
            : (e instanceof Error)
                ? new Err(e.message, opts)
                : new Err(e.toString(), opts);
}
/** A Result is either a success result identified by isOk=true,
 *  or an error result identified by isOk=false.  A success
 *  result has the success value in its 'val' property; an
 *  error result will have one or more 'Err' objects in its
 *  'errors' property.
 */
export class OkResult {
    isOk = true;
    val;
    constructor(v) { this.val = v; }
    /** return result of applying fn on val */
    chain(fn) {
        return fn(this.val);
    }
}
export class ErrResult {
    isOk = false;
    errors;
    constructor(errors = []) { this.errors = errors; }
    addError(e, options) {
        const errors = (e instanceof ErrResult) ? e.errors : [error(e, options)];
        return new ErrResult(this.errors.concat(errors));
    }
    /** ignore fn, simply returning this error result */
    chain(_fn) { return this; }
}
/** factory function for a success result */
export function okResult(v) { return new OkResult(v); }
/** factory function for an error result initialized to contain
 *  a single error as per e, options.
 */
export function errResult(e, options) {
    return new ErrResult().addError(e, options);
}
/*

//demo program

function safeDiv(num: number, denom: number) : Result<number> {
  if (denom === 0) return errResult('zero denominator');
  return okResult(num/denom);
}

function demo(result: Result<number>) : Result<string> {
  if (!result.isOk) return result as Result<string>;
  const v = result.val + 1;
  return result.chain((val: number) => okResult('x'.repeat(v*val)))
               .chain((str: string) => okResult(str + 'aaa'));
}

console.log(safeDiv(1, 0));
console.log(safeDiv(1, 2));
console.log(demo(errResult('some error', 'ERR_CODE')));
console.log(demo(okResult(2)));

*/
//# sourceMappingURL=errors.js.map